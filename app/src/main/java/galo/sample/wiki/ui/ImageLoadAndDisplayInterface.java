package galo.sample.wiki.ui;

import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.util.Log;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.ImageView;

import java.io.File;
import java.lang.ref.WeakReference;

import galo.sample.wiki.R;
import galo.sample.wiki.api.Page;

/**
 * Acting as an interface between an ImageView and an image-loading thread, it provides memory-
 * persisting way to bind a bitmap loading process to a dynamically changing ImageView, such as when
 * used for an adapter, giving a non-ui thread access to set the bitmap once it is loaded and setting
 * a bound ImageView's image once it is loaded.
 *
 * Created by Galo on 2/27/2015.
 */
public class ImageLoadAndDisplayInterface
{
    private final Page mPage;
    private File mImageFile;
    private boolean mRecycled;
    private WeakReference<ImageView> mBoundImageViewWRef;
    private Bitmap mBitmap;
    private boolean mShouldRecycleBitmap;

    public ImageLoadAndDisplayInterface(Page page)
    {
        this.mPage = page;
        mBoundImageViewWRef = new WeakReference<ImageView>(null);
    }

    /**
     * Retrieve the associated {@link galo.sample.wiki.api.Page} object storing information about
     * the remote page that the image was fetched from.
     *
     * @return
     * The page associated with it.
     */
    public Page getPage()
    {
        return mPage;
    }

    /**
     * Retrieves the associated local file storing an image.
     * @return
     * Returns the associated file holding the image.  Please note that it may point to a non-existing file
     * if the cache has been cleared, so a check for existence would be suggested before reading.
     */
    public File getImageFile()
    {
        return mImageFile;
    }

    /**
     * Associates a local file that a processing thread can use to load the image.
     *
     * @param imgFile
     * A local file containing the image or null if the file has not yet been set.
     */
    public void setImageFile(File imgFile)
    {
        mImageFile = imgFile;
    }

    public ImageView getBoundedImageView()
    {
        return mBoundImageViewWRef.get();
    }

    public Bitmap getBitmap()
    {
        return mBitmap;
    }

    /**
     * Sets the bitmap image to this interface, setting a bounded image view if it has one.
     * @param bmap
     * The bitmap to apply to this reference.
     * @param animate
     * True if you want the bitmap to animate, false if not.
     * @param recyleBitmapOnRecycleInvocation
     * True to set this Bitmap to get recycled when a recycle call is performed on this object.
     * False if it should not be recycled. (This means that somewhere else that is being taken care of).
     */
    public synchronized void setBitmap(Bitmap bmap, boolean animate, boolean recyleBitmapOnRecycleInvocation)
    {
        if(!mRecycled)
        {
            mShouldRecycleBitmap = recyleBitmapOnRecycleInvocation;
            mBitmap = bmap;
            ImageView iv = mBoundImageViewWRef != null ? mBoundImageViewWRef.get() : null;
            if (iv != null)
            {
                iv.setImageBitmap(bmap);
                iv.setContentDescription(mPage.getTitle());
                if(animate)
                {
                    Animation anim = AnimationUtils.loadAnimation(iv.getContext(), R.anim.fadein);
                    iv.startAnimation(anim);
                }
                // The first view would be getting internally recycled; thus, the first element would
                // never show because the last View generated by the adapter would be a 'scrap' view
                // at position 0.
                Log.d("img", ""+mPage.getIndex()+": w"+iv.getWidth()+" h"+iv.getHeight()+" parent:"+iv.getParent());
            }
        }
    }

    public synchronized void bindImageView(ImageView iv)
    {
        mBoundImageViewWRef = new WeakReference<ImageView>(iv);
        if(iv != null)
        {
            iv.setImageDrawable(mBitmap != null ? new BitmapDrawable(iv.getContext().getResources(), mBitmap) : null);
            iv.setContentDescription(mPage.getTitle());
        }
    }

    public synchronized void recycle()
    {
        if(mShouldRecycleBitmap && mBitmap != null && !mBitmap.isRecycled())
            mBitmap.recycle();
        mBitmap = null;
        ImageView iv = mBoundImageViewWRef != null ? mBoundImageViewWRef.get() : null;
        if(iv != null)
            iv.setImageDrawable(null);
        mRecycled = true;
    }

    public synchronized boolean isRecycled()
    {
        return mRecycled;
    }
}
